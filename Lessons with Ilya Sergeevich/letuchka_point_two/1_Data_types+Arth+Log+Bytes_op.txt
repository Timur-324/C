
1. Типы — кратко
- char (1 байт), signed char, unsigned char.
- short, int, long, long long — стандарт гарантирует минимумы (short≥16, long≥32, long long≥64); реальные размеры платформо‑зависимы (см. LP64/ILP32).
- _Bool (0 или 1).
- float, double, long double — плавающая точка (обычно IEEE‑754).
- указатели, массивы, struct/union, enum.
- stdint.h: intN_t/uintN_t, intptr_t, uintptr_t, size_t, ptrdiff_t — для переносимости.
- Квалификаторы: const, volatile, restrict — меняют семантику доступа, не представление.

2. Приведения и «usual arithmetic conversions»
- Integer promotions: все целые типы меньше int (char, short) продвигаются к int или unsigned int (если int не вмещает исходные значения).
- После продвижения для бинарных арифметических операторов выполняются usual arithmetic conversions:
  - если один операнд плавающий — другой приводится к более широкому плавающему;
  - если оба целые — выбирается тип по рангу/знаковости: mix signed/unsigned часто ведёт к unsigned.
- Итог: смешение signed/unsigned — частый источник ошибок.

3. Арифметические операции
- +, -, *, /, %.
- Целочисленное деление (C99 и далее) — округление к нулю: -7/3 == -2; остаток: a == (a/b)*b + (a%b), знак остатка = знак делимого.
- Деление на ноль для целых — undefined behavior (UB). Для float — обычно Inf/NaN (если поддерживается).
- Переполнение:
  - signed overflow — UB;
  - unsigned — арифметика по модулю 2^N (wrap-around).
- Инкремент/декремент: ++i/i++ важен порядок; чтение и изменение без упорядоченности — UB (пример: i = i++ + 1 — UB).
- compound (a += b) эквивалентно a = a + b по смыслу, но левый операнд вычисляется один раз.

4. Логические операции
- &&, ||, ! — преобразуют операнды в булевы (0 → false, ненулевое → true). Результат типа int: 0 или 1.
- Короткое замыкание: при && правый не вычисляется если левый false; при || — если левый true.
- Не путать с побитовыми & и | (работают над битами целых).

5. Побитовые операции и сдвиги
- Побитовые: ~, &, |, ^ — работают над целыми после продвижений/приведений.
- Для битовых манипуляций используйте unsigned (uint32_t/uint64_t) — предсказуемость и переносимость.
- Сдвиги: <<, >>.
  - Сдвиг отрицательного количества или >= ширины типа в битах — UB.
  - Левый сдвиг signed, если «затирает» бит знака — UB; для unsigned — определяется как умножение по модулю.
  - Правый сдвиг unsigned — логический (вставляются нули); signed — implementation‑defined (арифметический или логический).
- Рекомендация: все битовые операции и сдвиги — на unsigned.

6. Приоритет/ассоциативность — кратко
- *, /, % выше +, -.
- <<, >> между +/- и побитовыми &, ^, |.
- Побитовые ниже арифметических; логические &&, || — ещё ниже.
- Присваивание — очень низкий, справа‑налево ассо