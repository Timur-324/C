// Давайте разберём динамический массив. 
// Это структура данных, которая позволяет хранить элементы с возможностью изменения размера.
// В отличие от статического массива, размер динамического может изменяться во время выполнения программы.
// 
// ### Основные операции
// 
// 1. **Создание массива:**
//    - Используется функция `malloc` или `calloc` для выделения памяти.
//    - Сложность: \(O(1)\).
// 
// 2. **Удаление массива:**
//    - Используется функция `free` для освобождения памяти.
//    - Сложность: \(O(1)\).
// 
// 3. **Обращение к элементу по индексу:**
//    - Доступ осуществляется напрямую, как к обычному массиву.
//    - Сложность: \(O(1)\).
// 
// 4. **Добавление элемента:**
//    - **В конец:** При необходимости выделяется новый блок памяти большей размерности, и элементы копируются.
//      - Амортизированная сложность: \(O(1)\), но в худшем случае \(O(n)\).
//    - **В произвольное место:** Элементы после указанного индекса сдвигаются.
//      - Сложность: \(O(n)\).
// 
// 5. **Удаление элемента:**
//    - **Из произвольного места:** Элементы после удаляемого сдвигаются.
//    - Сложность: \(O(n)\).
// 
// 6. **Поиск элемента по значению:**
//    - Линейный поиск по массиву.
//    - Сложность: \(O(n)\).
// 
// ### Реализация на языке C
// 
// Рассмотрим реализацию динамического массива с базовыми операциями.


#include <stdio.h>
#include <stdlib.h>

// Структура для представления динамического массива
typedef struct {
    int *array;
    size_t used;
    size_t size;
} DynamicArray;

// Инициализация массива
void initArray(DynamicArray *a, size_t initialSize) {
    a->array = (int *)malloc(initialSize * sizeof(int));
    a->used = 0;
    a->size = initialSize;
}

// Добавление элемента в конец
void insertArray(DynamicArray *a, int element) {
    if (a->used == a->size) {
        a->size *= 2;
        a->array = (int *)realloc(a->array, a->size * sizeof(int));
    }
    a->array[a->used++] = element;
}

// Удаление элемента из массива (со сдвигом)
void removeElement(DynamicArray *a, size_t index) {
    if (index < a->used) {
        for (size_t i = index; i < a->used - 1; i++) {
            a->array[i] = a->array[i + 1];
        }
        a->used--;
    }
}

// Поиск элемента по значению
int findElement(DynamicArray *a, int value) {
    for (size_t i = 0; i < a->used; i++) {
        if (a->array[i] == value) {
            return i;
        }
    }
    return -1;
}

// Освобождение памяти
void freeArray(DynamicArray *a) {
    free(a->array);
    a->array = NULL;
    a->used = a->size = 0;
}

// Печать массива
void printArray(DynamicArray *a) {
    for (size_t i = 0; i < a->used; i++) {
        printf("%d ", a->array[i]);
    }
    printf("\n");
}

int main() {
    DynamicArray a;
    initArray(&a, 5);  // Инициализация массива размером 5

    // Добавление элементов
    insertArray(&a, 10);
    insertArray(&a, 20);
    insertArray(&a, 30);
    printArray(&a);

    // Удаление элемента
    removeElement(&a, 1);
    printArray(&a);

    // Поиск элемента
    int index = findElement(&a, 30);
    if (index != -1) {
        printf("Element 30 found at index: %d\n", index);
    } else {
        printf("Element not found\n");
    }

    // Освобождение памяти
    freeArray(&a);

    return 0;
}


// ### Подробности реализации
// 
// 1. **Инициализация:** Выделяем память для массива и устанавливаем начальные значения для `used` и `size`.
// 2. **Добавление:** Используем `realloc`, чтобы увеличить размер массива при необходимости.
// 3. **Удаление:** Сдвигаем элементы, чтобы заполнить пробел.
// 4. **Поиск:** Линейный поиск по массиву.
// 5. **Освобождение памяти:** Используем `free` для предотвращения утечек памяти.
// 
// Эта реализация охватывает основные функции динамического массива и демонстрирует, как можно эффективно управлять памятью в C. Если у вас есть вопросы или требуется дополнительное объяснение, дайте знать.